%skeleton "lalr1-c++17.cc"
%require "3.0.4"
%locations

%code requires {

#include "RefContainer.hpp"
#include "ast/All.hpp"

namespace udc {
    class Driver;
    class Scanner;
}

#ifdef _MSC_VER
#pragma warning(push)
// warning C4065: switch statement contains 'default' but no 'case' labels
#pragma warning(disable: 4065)
// warning C4244: 'return': conversion from 'std::streamsize' to 'int', possible loss of data
#pragma warning(disable: 4244)
#endif
}

%code provides {
#ifdef _MSC_VER
#pragma warning(pop)
#endif

namespace udc {
    using Token = Parser::symbol_type;
    using TokenId = Parser::token_type;
}
}

%code {
#include <utility>

#include "Driver.hpp"

#ifdef yylex
#undef yylex
#endif
#define yylex x_vScanner.NextToken
}

%defines
%define api.namespace {udc}
%define api.token.constructor
%define api.token.prefix {k}
%define api.value.type variant
%define parse.assert
%define parse.error verbose
%define parser_class_name {Parser}

%parse-param {Driver &x_vDriver}
%parse-param {Scanner &x_vScanner}

%token End 0 "end-of-file"

%token KwBool           "bool"
%token KwBreak          "break"
%token KwClass          "class"
%token KwElse           "else"
%token KwExtends        "extends"
%token KwFor            "for"
%token KwIf             "if"
%token KwInt            "int"
%token KwNew            "new"
%token KwNull           "null"
%token KwReturn         "return"
%token KwString         "string"
%token KwThis           "this"
%token KwVoid           "void"
%token KwWhile          "while"
%token KwStatic         "static"
%token KwPrint          "Print"
%token KwReadInteger    "ReadInteger"
%token KwReadLine       "ReadLine"
%token KwInstanceOf     "instanceof"

%token <std::string>    Identifier  "identifier"
%token <int>            IntLit      "integer-literal"
%token <bool>           BoolLit     "bool-literal"
%token <std::string>    StrLit      "string-literal"

%token OpAdd "+"
%token OpSub "-"
%token OpMul "*"
%token OpDiv "/"
%token OpMod "%"
%token OpLes "<"
%token OpLeq "<="
%token OpGre ">"
%token OpGeq ">="
%token OpAsg "="
%token OpEqu "=="
%token OpNeq "!="
%token OpAnd "&&"
%token OpIor "||"
%token OpNot "!"

%token PuSem ";"
%token PuCom ","
%token PuDot "."
%token PuSqo "["
%token PuSqc "]"
%token PuRno "("
%token PuRnc ")"
%token PuCuo "{"
%token PuCuc "}"

%type <RefVec<ast::ClassDef>> ClassDefList
%type <ast::ClassDef *> ClassDef
%type <RefVec<ast::NodeBase>> FieldListOpt BlockItemListOpt
%type <ast::VarDef *> VariableDef Variable
%type <ast::FnDef *> FunctionDef
%type <ast::TypeName *> Type
%type <RefVec<ast::VarDef>> Formals VariableList
%type <ast::BlockStmt *> BlockStmt
%type <ast::NodeBase *> Stmt
%type <ast::IfStmt *> IfStmt
%type <ast::WhileStmt *> WhileStmt
%type <ast::ForStmt *> ForStmt
%type <ast::BreakStmt *> BreakStmt
%type <ast::ReturnStmt *> ReturnStmt
%type <ast::PrintStmt *> PrintStmt
%type <ast::ExprBase *> Expr ExprOpt Call PrimaryExpr PrimaryNoNewArray
%type <ast::ExprBase *> OrExpr AndExpr EquExpr RelExpr AddExpr MulExpr UnaryExpr
%type <ast::ExprBase *> Literal LValue
%type <RefVec<ast::ExprBase>> Actuals ExprList

%precedence UnmatchedIf
%precedence "else"

%start Program

%%
Program:
    ClassDefList[cdl] {
        x_vDriver.SetProgram(x_vDriver.AddNode<ast::Program>(@1, std::move($cdl)));
    };

ClassDefList:
    ClassDef[cd] {
        $$.emplace_back(*std::move($cd));
    } |
    ClassDefList[cdl] ClassDef[cd] {
        $$ = std::move($cdl);
        $$.emplace_back(*std::move($cd));
    };

ClassDef:
    "class" Identifier[id] "{" FieldListOpt[fl] "}" {
        $$ = &x_vDriver.AddNode<ast::ClassDef>(@1, std::move($id), std::nullopt, std::move($fl));
    } |
    "class" Identifier[id] "extends" Identifier[base] "{" FieldListOpt[fl] "}" {
        $$ = &x_vDriver.AddNode<ast::ClassDef>(@1, std::move($id), std::move($base), std::move($fl));
    };

FieldListOpt:
    %empty {} |
    FieldListOpt[fl] VariableDef[vd] {
        $$ = std::move($fl);
        $$.emplace_back(*std::move($vd));
    } |
    FieldListOpt[fl] FunctionDef[fd] {
        $$ = std::move($fl);
        $$.emplace_back(*std::move($fd));
    };

VariableDef:
    Variable[var] ";" {
        $$ = std::move($var);
    };

Variable:
    Type[ty] Identifier[id] {
        $$ = &x_vDriver.AddNode<ast::VarDef>(@1, std::move($ty), std::move($id));
    };

Type:
    "void" {
        $$ = &x_vDriver.AddNode<ast::TypeName>(@1, ast::TypeId::kVoid);
    } |
    "int" {
        $$ = &x_vDriver.AddNode<ast::TypeName>(@1, ast::TypeId::kInt);
    } |
    "bool" {
        $$ = &x_vDriver.AddNode<ast::TypeName>(@1, ast::TypeId::kBool);
    } |
    "string" {
        $$ = &x_vDriver.AddNode<ast::TypeName>(@1, ast::TypeId::kString);
    } |
    "class" Identifier[id] {
        $$ = &x_vDriver.AddNode<ast::TypeName>(@1, std::move($id));
    } |
    Type[ty] "[" "]" {
        $$ = std::move($ty);
        $$->AddDimension();
    };

FunctionDef:
    Type[ty] Identifier[id] "(" Formals[pars] ")" BlockStmt[body] {
        $$ = &x_vDriver.AddNode<ast::FnDef>(@1, false, std::move($ty), std::move($id), std::move($pars), std::move($body));
    } |
    "static" Type[ty] Identifier[id] "(" Formals[pars] ")" BlockStmt[body] {
        $$ = &x_vDriver.AddNode<ast::FnDef>(@1, true, std::move($ty), std::move($id), std::move($pars), std::move($body));
    };

Formals:
    %empty {} |
    VariableList[vl] {
        $$ = std::move($vl);
    };

VariableList:
    Variable[v] {
        $$.emplace_back(*std::move($v));
    } |
    VariableList[vl] "," Variable[v] {
        $$ = std::move($vl);
        $$.emplace_back(*std::move($v));
    };

BlockStmt:
    "{" BlockItemListOpt[bil] "}" {
        $$ = &x_vDriver.AddNode<ast::BlockStmt>(@1, std::move($bil));
    };

BlockItemListOpt:
    %empty {} |
    BlockItemListOpt[bil] VariableDef[vd] {
        $$ = std::move($bil);
        $$.emplace_back(*std::move($vd));
    } |
    BlockItemListOpt[bil] Stmt[st] {
        $$ = std::move($bil);
        $$.emplace_back(*std::move($st));
    };

Stmt:
    ";" {
        $$ = &x_vDriver.AddNode<ast::ExprStmt>(@1, nullptr);
    } |
    Expr[e] ";" {
        $$ = &x_vDriver.AddNode<ast::ExprStmt>(@1, std::move($e));
    } |
    IfStmt[st] {
        $$ = std::move($st);
    } |
    WhileStmt[st] {
        $$ = std::move($st);
    } |
    ForStmt[st] {
        $$ = std::move($st);
    } |
    BreakStmt[st] {
        $$ = std::move($st);
    } |
    ReturnStmt[st] {
        $$ = std::move($st);
    } |
    PrintStmt[st] {
        $$ = std::move($st);
    } |
    BlockStmt[st] {
        $$ = std::move($st);
    };

Expr:
    OrExpr[e] {
        $$ = std::move($e);
    } |
    LValue[l] "=" Expr[r] {
        $$ = &x_vDriver.AddNode<ast::AssignExpr>(@1, std::move($l), std::move($r));
    };

OrExpr:
    AndExpr[e] {
        $$ = std::move($e);
    } |
    OrExpr[l] "||" AndExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kIor, std::move($l), std::move($r));
    };

AndExpr:
    EquExpr[e] {
        $$ = std::move($e);
    } |
    AndExpr[l] "&&" EquExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kAnd, std::move($l), std::move($r));
    };

EquExpr:
    RelExpr[e] {
        $$ = std::move($e);
    } | 
    EquExpr[l] "==" RelExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kEqu, std::move($l), std::move($r));
    } |
    EquExpr[l] "!=" RelExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kNeq, std::move($l), std::move($r));
    };

RelExpr:
    AddExpr[e] {
        $$ = std::move($e);
    } |
    RelExpr[l] "<" AddExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kLes, std::move($l), std::move($r));
    } |
    RelExpr[l] ">" AddExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kGre, std::move($l), std::move($r));
    } |
    RelExpr[l] "<=" AddExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kLeq, std::move($l), std::move($r));
    } |
    RelExpr[l] ">=" AddExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kGeq, std::move($l), std::move($r));
    };

AddExpr:
    MulExpr[e] {
        $$ = std::move($e);
    } |
    AddExpr[l] "+" MulExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kAdd, std::move($l), std::move($r));
    } |
    AddExpr[l] "-" MulExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kSub, std::move($l), std::move($r));
    };

MulExpr:
    UnaryExpr[e] {
        $$ = std::move($e);
    } |
    MulExpr[l] "*" UnaryExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kMul, std::move($l), std::move($r));
    } |
    MulExpr[l] "/" UnaryExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kDiv, std::move($l), std::move($r));
    } |
    MulExpr[l] "%" UnaryExpr[r] {
        $$ = &x_vDriver.AddNode<ast::BinaryExpr>(@1, ast::BinOp::kMod, std::move($l), std::move($r));
    };

UnaryExpr:
    PrimaryExpr[e] {
        $$ = std::move($e);
    } |
    "-" UnaryExpr[e] {
        $$ = &x_vDriver.AddNode<ast::UnaryExpr>(@1, ast::UnaOp::kNeg, std::move($e));
    } |
    "!" UnaryExpr[e] {
        $$ = &x_vDriver.AddNode<ast::UnaryExpr>(@1, ast::UnaOp::kNot, std::move($e));
    } |
    "(" "class" Identifier[id] ")" UnaryExpr[e] {
        $$ = &x_vDriver.AddNode<ast::CastExpr>(@1, std::move($id), std::move($e));
    };

PrimaryExpr:
    PrimaryNoNewArray[e] {
        $$ = std::move($e);
    } |
    "new" Type[ty] "[" Expr[e] "]" {
        $$ = &x_vDriver.AddNode<ast::NewArrayExpr>(@1, std::move($ty), std::move($e));
    };

PrimaryNoNewArray:
    Literal[e] {
        $$ = std::move($e);
    } |
    "this" {
        $$ = &x_vDriver.AddNode<ast::This>(@1);
    } |
    LValue[e] {
        $$ = std::move($e);
    } |
    "(" Expr[e] ")" {
        $$ = std::move($e);
    } |
    "new" Identifier[id] "(" ")" {
        $$ = &x_vDriver.AddNode<ast::NewClassExpr>(@1, std::move($id));
    } |
    Call[e] {
        $$ = std::move($e);
    };

Literal:
    "null" {
        $$ = &x_vDriver.AddNode<ast::NullLit>(@1);
    } |
    IntLit[n] {
        $$ = &x_vDriver.AddNode<ast::IntLit>(@1, $n);
    } |
    BoolLit[b] {
        $$ = &x_vDriver.AddNode<ast::BoolLit>(@1, $b);
    } |
    StrLit[s] {
        $$ = &x_vDriver.AddNode<ast::StrLit>(@1, std::move($s));
    };

LValue:
    Identifier[id] {
        $$ = &x_vDriver.AddNode<ast::VarAccess>(@1, nullptr, std::move($id));
    } |
    PrimaryExpr[e] "." Identifier[id] {
        $$ = &x_vDriver.AddNode<ast::VarAccess>(@1, std::move($e), std::move($id));
    } |
    PrimaryNoNewArray[e] "[" Expr[sub] "]" {
        $$ = &x_vDriver.AddNode<ast::ArrayAccess>(@1, std::move($e), std::move($sub));
    };

Call:
    Identifier[id] "(" Actuals[args] ")" {
        $$ = &x_vDriver.AddNode<ast::CallExpr>(@1, nullptr, std::move($id), std::move($args));
    } |
    PrimaryExpr[e] "." Identifier[id] "(" Actuals[args] ")" {
        $$ = &x_vDriver.AddNode<ast::CallExpr>(@1, std::move($e), std::move($id), std::move($args));
    } |
    "ReadInteger" "(" ")" {
        $$ = &x_vDriver.AddNode<ast::ReadInteger>(@1);
    } |
    "ReadLine" "(" ")" {
        $$ = &x_vDriver.AddNode<ast::ReadLine>(@1);
    } |
    "instanceof" "(" Expr[e] "," Identifier[id] ")" {
        $$ = &x_vDriver.AddNode<ast::InstanceOf>(@1, std::move($e), std::move($id));
    };

Actuals:
    %empty {} |
    ExprList[el] {
        $$ = std::move($el);
    };

ExprList:
    Expr[e] {
        $$.emplace_back(*std::move($e));
    } |
    ExprList[el] "," Expr[e] {
        $$ = std::move($el);
        $$.emplace_back(*std::move($e));
    };

IfStmt:
    "if" "(" Expr[e] ")" Stmt[st] %prec UnmatchedIf {
        $$ = &x_vDriver.AddNode<ast::IfStmt>(@1, std::move($e), std::move($st), nullptr);
    } |
    "if" "(" Expr[e] ")" Stmt[st] "else" Stmt[est] {
        $$ = &x_vDriver.AddNode<ast::IfStmt>(@1, std::move($e), std::move($st), std::move($est));
    };

WhileStmt:
    "while" "(" Expr[e] ")" Stmt[st] {
        $$ = &x_vDriver.AddNode<ast::WhileStmt>(@1, std::move($e), std::move($st));
    };

ForStmt:
    "for" "(" ExprOpt[e1] ";" ExprOpt[e2] ";" ExprOpt[e3] ")" Stmt[st] {
        $$ = &x_vDriver.AddNode<ast::ForStmt>(@1, std::move($e1), std::move($e2), std::move($e3), std::move($st));
    };

ExprOpt:
    %empty {} |
    Expr[e] {
        $$ = std::move($e);
    };

BreakStmt:
    "break" ";" {
        $$ = &x_vDriver.AddNode<ast::BreakStmt>(@1);
    };

ReturnStmt:
    "return" ExprOpt[e] ";" {
        $$ = &x_vDriver.AddNode<ast::ReturnStmt>(@1, std::move($e));
    };

PrintStmt:
    "Print" "(" ExprList[el] ")" ";" {
        $$ = &x_vDriver.AddNode<ast::PrintStmt>(@1, std::move($el));
    }

%%

void ::udc::Parser::error(const location_type &vLoc, const std::string &sMsg) {
    x_vDriver.PrintError(vLoc, sMsg);
}
